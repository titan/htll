(load "view.scm")

(define the-layout-tree '())

(define the-variables '()) ; (list (cons var (cons value root)))

(define (lookup-variable-by-value val root)
  (let loop ((vars the-variables))
    (if (not (null? vars))
        (if (and (eq? val (cadar vars)) (eq? root (cddar vars)))
            (caar vars)
            (loop (cdr vars)))
        (error "No binding found for " val "in" root))))

(define (lookup-variable-by-value-ignoring-root val)
  (let loop ((vars the-variables))
    (if (not (null? vars))
        (if (eq? val (cadar vars))
            (caar vars)
            (loop (cdr vars)))
        #f)))

(define (scan-variable-value root env)
  (define (env-loop env)
    (define (scan vars vals)
      (if (null? vars)
          (env-loop (enclosing-environment env))
          (let ((var (car vars))
                (val (car vals)))
            (if (and (pair? val) (assq (view-type val) the-type-definitions))
                (let ((tmp (assq var the-variables)))
                  (if tmp
                      (if (not (eq? (cadr tmp) val))
                          (error var "binds to two values"))
                      (set! the-variables (cons (cons var (cons val root)) the-variables)))))
            (scan (cdr vars) (cdr vals)))))
    (if (not (eq? env the-empty-environment))
        (let ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))
  (env-loop env))

(define (generate-normal-init type view)
  (string-append "[[" type " alloc] init]"))

(define (generate-button-init type view)
  (let ((tag (view-type view)))
    (string-append "[" type " buttonWithType:"
                   (cond ((eq? tag 'rounded-rect-button) "UIButtonTypeRoundedRect")
                         ((eq? tag 'detail-disclosure-button) "UIButtonTypeDetailDisclosure")
                         ((eq? tag 'info-light-button) "UIButtonTypeInfoLight")
                         ((eq? tag 'info-dark-button) "UIButtonTypeInfoDark")
                         ((eq? tag 'contact-add-button) "UIButtonTypeContactAdd")
                         (else "UIButtonTypeCustom")) "]")))

(define (generate-font-init type view)
  (let ((tag (view-type view)))
    (cond
     ((eq? tag 'font) (string-append "[" type " name:@\"" (cadr view) "\" size:" (number->string (caddr view)) "]"))
     ((eq? tag 'system-font-of-size) (string-append "[" type " systemFontOfSize:" (number->string (cadr view)) "]"))
     ((eq? tag 'bold-system-font-of-size) (string-append "[" type " boldSystemFontOfSize:" (number->string (cadr view)) "]"))
     ((eq? tag 'italic-system-font-of-size) (string-append "[" type " italicSystemFontOfSize:" (number->string (cadr view)) "]")))))

(define (generate-segmented-control-init type view)
  (let* ((attrs (view-attributes view))
         (items (assq 'items attrs)))
    (if items
        (let loop ((array (reverse (cdr items)))
                   (result '()))
          (if (null? array)
              (string-append "[[" type " alloc] initWithItems:" (generate-array result) "]")
              (let ((ref (lookup-variable-by-value-ignoring-root (car array))))
                (if ref
                    (loop (cdr array) (cons (symbol->string ref) result))
                    (cond
                     ((string? (car array)) (loop (cdr array) (cons (generate-string (car array)) result)))
                     ((eq? 'image-named (view-type (car array))) (loop (cdr array) (cons (generate-image-named (car array)) result)))
                     (else (error "Unsupported type " (car array) "need string or image")))))))
        (error "Missing items in " view))))

(define the-resource-types
  '(font system-font-of-size bold-system-font-of-size italic-system-font-of-size image-named hsba-color rgba-color))

(define the-type-definitions ; (list (cons view-type (cons type-string init-fun)))
  (list (cons 'view (cons "UIView" generate-normal-init))
        (cons 'scroll (cons "UIScrollView" generate-normal-init))
        (cons 'font (cons "UIFont" generate-font-init))
        (cons 'system-font-of-size (cons "UIFont" generate-font-init))
        (cons 'bold-system-font-of-size (cons "UIFont" generate-font-init))
        (cons 'italic-system-font-of-size (cons "UIFont" generate-font-init))
        (cons 'label (cons "UILabel" generate-normal-init))
        (cons 'custom-button (cons "UIButton" generate-button-init))
        (cons 'rounded-rect-button (cons "UIButton" generate-button-init))
        (cons 'detail-disclosure-button (cons "UIButton" generate-button-init))
        (cons 'info-light-button (cons "UIButton" generate-button-init))
        (cons 'info-dark-button (cons "UIButton" generate-button-init))
        (cons 'contact-add-button (cons "UIButton" generate-button-init))
        (cons 'image (cons "UIImageView" generate-normal-init))
        (cons 'slider (cons "UISlider" generate-normal-init))
        (cons 'segmented-control (cons "UISegmentedControl" generate-segmented-control-init))
        (cons 'text-field (cons "UITextField" generate-normal-init))
        (cons 'text-view (cons "UITextView" generate-normal-init))
        (cons 'table (cons "UITableView" generate-normal-init))))

(define (type-definition-type definition)
  (car definition))

(define (type-definition-type-string definition)
  (cadr definition))

(define (type-definition-init-fun definition)
  (cddr definition))

(define (view-attributes view)
  (cadr view))

(define (view attrs)
  (list 'view attrs))

(define (scroll attrs)
  (list 'scroll attrs))

(define (label attrs)
  (list 'label attrs))

(define (custom-button attrs)
  (list 'custom-button attrs))

(define (rounded-rect-button attrs)
  (list 'rounded-rect-button attrs))

(define (detail-disclosure-button attrs)
  (list 'detail-disclosure-button attrs))

(define (info-light-button attrs)
  (list 'info-light-button attrs))

(define (info-dark-button attrs)
  (list 'info-dark-button attrs))

(define (contact-add-button attrs)
  (list 'contact-add-button attrs))

(define (image attrs)
  (let ((ref (assq 'image attrs)))
    (if ref
        (list 'image attrs)
        (error "Missing image" attrs))))

(define (slider attrs)
  (list 'slider attrs))

(define (segmented-control attrs)
  (list 'segmented-control attrs))

(define (text-field attrs)
  (list 'text-field attrs))

(define (text-view attrs)
  (list 'text-view attrs))

(define (table attrs)
  (list 'table attrs))

(define (localized key default)
  (if (and (string? key) (string? default))
      (list 'localized key default)
      (error "Invalid localized" key default)))

(define (localized-key value)
  (cadr value))

(define (localized-default value)
  (caddr value))

(define (hsba-color hue saturation brightness alpha)
  (if (and (real? hue) (real? saturation) (real? brightness) (real? alpha))
      (list 'hsba-color hue saturation brightness alpha)
      (error "Invalid hsba-color" hue saturation brightness alpha)))

(define (rgba-color red green blue alpha)
  (if (and (real? red) (real? green) (real? blue) (real? alpha))
      (list 'rgba-color red green blue alpha)
      (error "Invalid rgba-color" red green blue alpha)))

(define (system-font-of-size size)
  (if (number? size)
      (list 'system-font-of-size size)
      (error "Invalid system-font-of-size" size)))

(define (bold-system-font-of-size size)
  (if (number? size)
      (list 'bold-system-font-of-size size)
      (error "Invalid bold-system-font-of-size" size)))

(define (italic-system-font-of-size size)
  (if (number? size)
      (list 'italic-system-font-of-size size)
      (error "Invalid italic-system-font-of-size" size)))

(define (font name size)
  (if (and (string? name) (number? size))
      (list 'font name size)
      (error "Invalid font" name size)))

(define (label-font-size)
  (list 'label-font-size))

(define (button-font-size)
  (list 'button-font-size))

(define (small-system-font-size)
  (list 'small-system-font-size))

(define (system-font-size)
  (list 'system-font-size))

(define (image-named name)
  (if (string? name)
      (list 'image-named name)
      (error "Invalid image-named" name)))

(define (size width height)
  (if (and (number? width) (number? height))
      (list 'size width height)
      (error "Invalid size" width height)))

(define (rect x y width height)
  (if (and (number? x) (number? y) (number? width) (number? height))
      (list 'rect x y width height)
      (error "Invalid rect" x y width height)))

(define (edge-insets top left bottom right)
  (if (and (number? top) (number? left) (number? bottom) (number? right))
      (list 'edge-insets top left bottom right)
      (error "Invalid edge-insets" top left bottom right)))

(define (offset h v)
  (if (and (number? h) (number? v))
      (list 'offset h v)
      (error "Invalid offset" h v)))

(define (range loc len)
  (if (and (number? loc) (number? len))
      (list 'range loc len)
      (error "Invalid range" loc len)))

(define (blank)
  (list 'blank))

(define (in children parent)
  (scan-variable-value parent the-current-environment)
  (set! the-layout-tree (cons (cons parent children) the-layout-tree)))

(define (in-cell children parent)
  (scan-variable-value parent the-current-environment)
  (set! the-layout-tree (cons (cons parent children) the-layout-tree)))

(define (view-type view)
  (car view))

(define (view-margin view)
  (cadddr view))

(define (view-ratio view)
  (cadddr view))

(define (left-view view)
  (cadr view))

(define (right-view view)
  (caddr view))

(define (up-view view)
  (cadr view))

(define (low-view view)
  (caddr view))

(define (^^ up low . margin)
  (cond
   ((= 0 (length margin))
    (list '^^ up low 0))
   ((= 1 (length margin))
    (cons '^^ (cons up (cons low margin))))
   (else (error "Wrong number of parameters in ^^" up low margin))))

(define (vv up low . margin)
  (cond
   ((= 0 (length margin))
    (list 'vv up low 0))
   ((= 1 (length margin))
    (cons 'vv (cons up (cons low margin))))
   (else (error "Wrong number of parameters in vv" up low margin))))

(define (<< left right . margin)
  (cond
   ((= 0 (length margin))
    (list '<< left right 0))
   ((= 1 (length margin))
    (cons '<< (cons left (cons right margin))))
   (else (error "Wrong number of parameters in <<" left right margin))))

(define (>> left right . margin)
  (cond
   ((= 0 (length margin))
    (list '>> left right 0))
   ((= 1 (length margin))
    (cons '>> (cons left (cons right margin))))
   (else (error "Wrong number of parameters in >>" left right margin))))

(define (h... . views)
  (define (hseq views)
    (let ((head (car views))
          (tail (cdr views)))
      (if (= 1 (length views))
          head
          (<< head (hseq tail)))))
  (hseq views))

(define (v... . views)
  (define (vseq views)
    (let ((head (car views))
          (tail (cdr views)))
      (if (= 1 (length views))
          head
          (^^ head (vseq tail)))))
  (vseq views))

(define (above up low ratio)
  (list 'above up low ratio))

(define (beside left right ratio)
  (list 'beside left right ratio))

(define (center view horizontal-ratio vertical-ratio)
  (let ((r1 (/ (- 1 (* 2 horizontal-ratio)) (- 1 horizontal-ratio)))
        (r2 (/ (- 1 (* 2 vertical-ratio)) (- 1 vertical-ratio))))
    (beside (blank) (beside (above (blank) (above view (blank) r2) vertical-ratio) (blank) r1) horizontal-ratio)))

(define (horizontal-sequence . views)
  (define (hseq views)
    (let ((head (car views))
          (tail (cdr views))
          (len (length views)))
      (if (= 1 len)
          head
          (beside head (hseq tail) (/ 1 len)))))
  (hseq views))

(define (vertical-sequence . views)
  (define (vseq views)
    (let ((head (car views))
          (tail (cdr views))
          (len (length views)))
      (if (= 1 len)
          head
          (above head (vseq tail) (/ 1 len)))))
  (vseq views))

(define dsl-procedures
  (list (list 'in in)
        (list 'in-cell in-cell)
        (list '<< <<)
        (list '>> >>)
        (list '^^ ^^)
        (list 'vv vv)
        (list 'h... h...)
        (list 'v... v...)
        (list 'above above)
        (list 'beside beside)
        (list 'center center)
        (list 'hseq horizontal-sequence)
        (list 'vseq vertical-sequence)
        (list 'view view)
        (list 'scroll scroll)
        (list 'label label)
        (list 'custom-button custom-button)
        (list 'rounded-rect-button rounded-rect-button)
        (list 'detail-disclosure-button detail-disclosure-button)
        (list 'info-light-button info-light-button)
        (list 'info-dark-button info-dark-button)
        (list 'contact-add-button contact-add-button)
        (list 'image image)
        (list 'slider slider)
        (list 'segmented-control segmented-control)
        (list 'text-field text-field)
        (list 'text-view text-view)
        (list 'table table)
        (list 'localized localized)
        (list 'hsba-color hsba-color)
        (list 'rgba-color rgba-color)
        (list 'font font)
        (list 'image-named image-named)
        (list 'system-font-of-size system-font-of-size)
        (list 'bold-system-font-of-size bold-system-font-of-size)
        (list 'italic-system-font-of-size italic-system-font-of-size)
        (list 'label-font-size label-font-size)
        (list 'button-font-size button-font-size)
        (list 'small-system-font-size small-system-font-size)
        (list 'system-font-size system-font-size)
        (list 'size size)
        (list 'rect rect)
        (list 'edge-insets edge-insets)
        (list 'offset offset)
        (list 'range range)))

(define (dsl-procedure-names)
  (map car dsl-procedures))

(define (dsl-procedure-objects)
  (map (lambda (proc) (list 'primitive (cadr proc))) dsl-procedures))

(define (setup-dsl-environment env)
  (let ((initial-env (extend-environment (dsl-procedure-names)
                                         (dsl-procedure-objects)
                                         env)))
    (define-variable! 'blank (blank) initial-env)
    (define-variable! 'yes #t initial-env)
    (define-variable! 'no #f initial-env)
    (set! the-current-environment initial-env)
    initial-env))

(define (generate-property-by-type-definition type var)
  (display (string-append "@property (nonatomic, strong) " type " * " (symbol->string var) ";"))
  (newline))

(define (generate-property env)
  (let loop ((vars the-variables))
    (if (not (null? vars))
        (let ((definition (assq (view-type (cadar vars)) the-type-definitions)))
          (if definition
              (generate-property-by-type-definition (type-definition-type-string definition) (caar vars)))
          (loop (cdr vars))))))

(define (generate-synthesize env)
  (define (generate var)
    (display (string-append "@synthesize " (symbol->string var) ";"))
    (newline))
  (let loop ((vars the-variables))
    (if (not (null? vars))
        (begin
          (generate (caar vars))
          (loop (cdr vars))))))

(define (generate-view-did-load env)
  (define (generate type type-string init-fun root var view)
    (display (string-append (symbol->string var) " = " (init-fun type-string view) ";"))
    (newline)
    (let ((res (memq type the-resource-types)))
      (if (not res) ; resource types don't need to be add to root view
          (begin
            (display (string-append "[" (symbol->string root) " addSubview:" (symbol->string var) "];"))
            (newline)))))
  (let loop ((vars the-variables))
    (if (not (null? vars))
        (let ((definition (assq (view-type (cadar vars)) the-type-definitions)))
          (if definition
              (let ((type (type-definition-type definition))
                    (type-string (type-definition-type-string definition))
                    (init-fun (type-definition-init-fun definition))
                    (root (cddar vars))
                    (var (caar vars))
                    (view (cadar vars)))
                (generate type type-string init-fun root var view)))
          (loop (cdr vars))))))

(define (generate-view-attributes generators var view)
  (let ((varstr (symbol->string var)))
    (let loop ((attrs (view-attributes view)))
      (if (not (null? attrs))
          (let ((attr (car attrs)))
            (let ((generator (assq (car attr) generators)))
              (if generator
                  (begin
                    (if (caddr generator)
                        (display ((cadr generator) (symbol->string var) (caddr generator) (cdr attr)))
                        (display ((cadr generator) (symbol->string var) (cdr attr))))
                    (newline))
                  (error "Invalid attribute" (car attr) "for" var)))
            (loop (cdr attrs)))))))

(define the-attribute-generators
  (list (cons 'view the-view-attribute-generators)
        (cons 'scroll the-scroll-attribute-generators)
        (cons 'label the-label-attribute-generators)
        (cons 'custom-button the-button-attribute-generators)
        (cons 'rounded-rect-button the-button-attribute-generators)
        (cons 'detail-disclosure-button the-button-attribute-generators)
        (cons 'info-light-button the-button-attribute-generators)
        (cons 'info-dark-button the-button-attribute-generators)
        (cons 'contact-add-button the-button-attribute-generators)
        (cons 'image the-image-attribute-generators)
        (cons 'slider the-slider-attribute-generators)
        (cons 'segmented-control the-segmented-control-attribute-generators)
        (cons 'text-field the-text-field-attribute-generators)
        (cons 'text-view the-text-view-attribute-generators)
        (cons 'table the-table-attribute-generators)))

(define (generate-view-will-appear env)
  (let loop ((vars the-variables))
    (if (not (null? vars))
        (let ((generators (assq (view-type (cadar vars)) the-attribute-generators)))
          (if generators
              (generate-view-attributes (cdr generators) (caar vars) (cadar vars)))
          (loop (cdr vars))))))

(define (exp-optimizer exp)
  (define (combine exp)
    (define (b++ a b c) ; (+ (+ a b) c)
      (cond ((eq? a c) (exp-optimizer `(+ (* 2 ,a) ,b)))
            ((eq? b c) (exp-optimizer `(+ (* 2 ,b) ,a)))
            ((and (number? a) (number? c)) (exp-optimizer `(+ ,(+ a c) ,b)))
            ((and (number? b) (number? c)) (exp-optimizer `(+ ,(+ b c) ,a)))
            (else `(+ (+ ,a ,b) ,c))))
    (define (b+- a b c) ; (+ (- a b) c)
      (cond ((eq? a c) (exp-optimizer `(- (* 2 ,a) ,b)))
            ((eq? b c) a)
            ((and (number? a) (number? c)) (exp-optimizer `(- ,(+ a c) ,b)))
            ((and (number? b) (number? c)) (exp-optimizer `(+ ,a ,(- b c))))
            (else `(+ (- ,a ,b) ,c))))
    (define (b+* a b c) ; (+ (* a b) c)
      (cond ((eq? a c) (exp-optimizer `(* (+ 1 ,b) ,a)))
            ((eq? b c) (exp-optimizer `(* (+ 1 ,a) ,b)))
            (else `(+ (* ,a ,b) ,c))))
    (define (b-+ a b c) ; (- (+ a b) c)
      (cond ((eq? a c) b)
            ((eq? b c) a)
            ((and (number? a) (number? c)) (exp-optimizer `(+ ,(- a c) ,b)))
            ((and (number? b) (number? c)) (exp-optimizer `(+ ,(- b c) ,a)))
            (else `(- (+ ,a ,b) ,c))))
    (define (b-- a b c) ; (- (- a b) c)
      (cond ((eq? a c) (exp-optimizer `(- 0 ,b)))
            ((eq? b c) (exp-optimizer `(- ,a (* 2 ,b))))
            ((and (number? a) (number? c)) (exp-optimizer `(- ,(- a c) ,b)))
            ((and (number? b) (number? c)) (exp-optimizer `(- ,a ,(+ b c))))
            (else `(- (- ,a ,b) ,c))))
    (define (b-* a b c) ; (- (* a b) c)
      (cond ((eq? a c) (exp-optimizer `(* ,a (- ,b 1))))
            ((eq? b c) (exp-optimizer `(* ,b (- ,a 1))))
            (else `(- (* ,a ,b) ,c))))
    (define (b** a b c) ; (* (* a b) c)
      (cond ((and (number? a) (number? c)) (exp-optimizer `(* ,(* a c) ,b)))
            ((and (number? b) (number? c)) (exp-optimizer `(* ,(* b c) ,a)))
            (else `(* (* ,a ,b) ,c))))
    (define the-combine-single-b-patterns
      (list (cons '+ (list (cons '+ b++) (cons '- b+-) (cons '* b+*)))
            (cons '- (list (cons '+ b-+) (cons '- b--) (cons '* b-*)))
            (cons '* (list (cons '* b**)))))
    (define (combine-single-b op fst snd) ; (+ (* 2 x) x) => (* 3 x)
      (let ((a (cadr fst))
            (b (caddr fst))
            (c snd)
            (subop (car fst)))
        (let ((p0 (assq op the-combine-single-b-patterns)))
          (if p0
              (let ((p1 (assq subop (cdr p0))))
                (if p1
                    ((cdr p1) a b c)
                    `(,op ,fst ,snd)))
              `(,op ,fst ,snd)))))
    (define (a++ a b c) ; (+ a (+ b c))
      (cond ((eq? a b) (exp-optimizer `(+ (* 2 ,a) ,c)))
            ((eq? a c) (exp-optimizer `(+ (* 2 ,a) ,b)))
            ((and (number? a) (number? b)) (exp-optimizer `(+ ,(+ a b) ,c)))
            ((and (number? a) (number? c)) (exp-optimizer `(+ ,(+ a c) ,b)))
            (else `(+ ,a (+ ,b ,c)))))
    (define (a+- a b c) ; (+ a (- b c))
      (cond ((eq? a b) (exp-optimizer `(- (* 2 ,a) ,c)))
            ((eq? a c) b)
            ((and (number? a) (number? b)) (exp-optimizer `(- ,(+ a b) ,c)))
            ((and (number? a) (number? c)) (exp-optimizer `(+ ,(- a c) ,b)))
            (else `(+ ,a (- ,b ,c)))))
    (define (a+* a b c) ; (+ a (* b c))
      (cond ((eq? a b) (exp-optimizer `(* (+ 1 ,c) ,a)))
            ((eq? a c) (exp-optimizer `(* (+ 1 ,b) ,a)))
            (else `(+ ,a (* ,b ,c)))))
    (define (a-+ a b c) ; (- a (+ b c))
      (cond ((eq? a b) (exp-optimizer `(- 0 ,c)))
            ((eq? a c) (exp-optimizer `(- 0 ,b)))
            ((and (number? a) (number? b)) (exp-optimizer `(- ,(- a b) ,c)))
            ((and (number? a) (number? c)) (exp-optimizer `(- ,(- a c) ,b)))
            (else `(- ,a (+ ,b ,c)))))
    (define (a-- a b c) ; (- a (- b c))
      (cond ((eq? a b) c)
            ((eq? a c) (exp-optimizer `(- (* 2 ,a) ,b)))
            ((and (number? a) (number? b)) (exp-optimizer `(+ ,(- a b) ,c)))
            ((and (number? a) (number? c)) (exp-optimizer `(- ,(+ a c) ,b)))
            (else `(- ,a (- ,b ,c)))))
    (define (a-* a b c) ; (- a (* b c))
      (cond ((eq? a b) (exp-optimizer `(* (- 1 ,c) ,a)))
            ((eq? a c) (exp-optimizer `(* (- 1 ,b) ,a)))
            (else `(- ,a (* ,b ,c)))))
    (define (a** a b c) ; (* a (* b c))
      (cond ((and (number? a) (number? b)) (exp-optimizer `(* ,(* a b) ,c)))
            ((and (number? a) (number? c)) (exp-optimizer `(* ,(* a c) ,b)))
            (else `(* ,a (* ,b ,c)))))
    (define the-combine-single-a-patterns
      (list (cons '+ (list (cons '+ a++) (cons '- a+-) (cons '* a+*)))
            (cons '- (list (cons '+ a-+) (cons '- a--) (cons '* a-*)))
            (cons '* (list (cons '* a**)))))
    (define (combine-single-a op fst snd) ;; (- x (* 3 x)) => (* -2 x)
      (let ((a fst)
            (b (cadr snd))
            (c (caddr snd))
            (subop (car snd)))
        (let ((p0 (assq op the-combine-single-a-patterns)))
          (if p0
              (let ((p1 (assq subop (cdr p0))))
                (if p1
                    ((cdr p1) a b c)
                    `(,op ,fst ,snd)))
              `(,op ,fst ,snd)))))
    (define (+++ a b c d) ; (+ (+ a b) (+ c d))
      (cond ((eq? a c) (exp-optimizer `(+ (* 2 ,a) (+ ,b ,d))))
            ((eq? a d) (exp-optimizer `(+ (* 2 ,a) (+ ,b ,c))))
            ((eq? b c) (exp-optimizer `(+ (* 2 ,b) (+ ,a ,d))))
            ((eq? b d) (exp-optimizer `(+ (* 2 ,b) (+ ,a ,c))))
            ((and (number? a) (number? c)) (exp-optimizer `(+ ,(+ a c) (+ ,b ,d))))
            ((and (number? a) (number? d)) (exp-optimizer `(+ ,(+ a d) (+ ,b ,c))))
            ((and (number? b) (number? c)) (exp-optimizer `(+ ,(+ b c) (+ ,a ,d))))
            ((and (number? b) (number? d)) (exp-optimizer `(+ ,(+ b d) (+ ,a ,c))))
            (else `(+ (+ ,a ,b) (+ ,c ,d)))))
    (define (++- a b c d) ; (+ (+ a b) (- c d))
      (cond ((eq? a c) (exp-optimizer `(+ (* 2 ,a) (- ,b ,d))))
            ((eq? a d) (exp-optimizer `(+ ,b ,c)))
            ((eq? b c) (exp-optimizer `(+ (* 2 ,b) (- ,c ,d))))
            ((eq? b d) (exp-optimizer `(+ ,a ,c)))
            ((and (number? a) (number? c)) (exp-optimizer `(+ ,(+ a c) (- ,b ,d))))
            ((and (number? a) (number? d)) (exp-optimizer `(+ ,(- a d) (+ ,b ,c))))
            ((and (number? b) (number? c)) (exp-optimizer `(+ ,(+ b c) (- ,a ,d))))
            ((and (number? b) (number? d)) (exp-optimizer `(+ ,(- b d) (+ ,a ,c))))
            (else `(+ (+ ,a ,b) (- ,c ,d)))))
    (define (+-+ a b c d) ; (+ (- a b) (+ c d))
      (cond ((eq? a c) (exp-optimizer `(+ (* 2 ,a) (- ,d ,b))))
            ((eq? a d) (exp-optimizer `(+ (* 2 ,a) (- ,c ,b))))
            ((eq? b c) (exp-optimizer `(+ ,a ,d)))
            ((eq? b d) (exp-optimizer `(+ ,a ,c)))
            ((and (number? a) (number? c)) (exp-optimizer `(+ ,(+ a c) (- ,d ,b))))
            ((and (number? a) (number? d)) (exp-optimizer `(+ ,(+ a d) (- ,c ,b))))
            ((and (number? b) (number? c)) (exp-optimizer `(+ ,(- c b) (+ ,a ,d))))
            ((and (number? b) (number? d)) (exp-optimizer `(+ ,(- d b) (+ ,a ,c))))
            (else `(+ (- ,a ,b) (+ ,c ,d)))))
    (define (+-- a b c d) ; (+ (- a b) (- c d))
      (cond ((eq? a c) (exp-optimizer `(- (* 2 ,a) (+ ,b ,d))))
            ((eq? a d) (exp-optimizer `(- ,c ,b)))
            ((eq? b c) (exp-optimizer `(- ,a ,d)))
            ((eq? b d) (exp-optimizer `(- (+ ,a ,c) (* 2 ,b))))
            ((and (number? a) (number? c)) (exp-optimizer `(- ,(+ a c) (+ ,b ,d))))
            ((and (number? a) (number? d)) (exp-optimizer `(+ ,(- a d) (- ,c ,b))))
            ((and (number? b) (number? c)) (exp-optimizer `(+ ,(- c b) (- ,a ,d))))
            ((and (number? b) (number? d)) (exp-optimizer `(- (+ ,a ,c) ,(+ b d))))
            (else `(+ (- ,a ,b) (- ,c ,d)))))
    (define (+** a b c d) ; (+ (* a b) (* c d))
      (cond ((and (number? a) (number? c) (symbol? b) (symbol? d) (eq? b d)) (exp-optimizer `(* ,(+ a c) ,b)))
            ((and (number? a) (number? d) (symbol? b) (symbol? c) (eq? b c)) (exp-optimizer `(* ,(+ a d) ,b)))
            ((and (number? b) (number? c) (symbol? a) (symbol? d) (eq? a d)) (exp-optimizer `(* ,(+ b c) ,a)))
            ((and (number? b) (number? d) (symbol? a) (symbol? c) (eq? a c)) (exp-optimizer `(* ,(+ b d) ,a)))
            ((eq? a c) (exp-optimizer `(* ,a (+ ,b ,d))))
            ((eq? a d) (exp-optimizer `(* ,a (+ ,b ,c))))
            ((eq? b c) (exp-optimizer `(* ,b (+ ,a ,d))))
            ((eq? b d) (exp-optimizer `(* ,b (+ ,a ,c))))
            (else `(+ (* ,a ,b) (* ,c ,d)))))
    (define (-++ a b c d) ; (- (+ a b) (+ c d))
      (cond ((eq? a c) (exp-optimizer `(- ,b ,d)))
            ((eq? a d) (exp-optimizer `(- ,b ,c)))
            ((eq? b c) (exp-optimizer `(- ,a ,d)))
            ((eq? b d) (exp-optimizer `(- ,a ,c)))
            ((and (number? a) (number? c)) (exp-optimizer `(+ ,(- a c) (- ,b ,d))))
            ((and (number? a) (number? d)) (exp-optimizer `(+ ,(- a d) (- ,b ,c))))
            ((and (number? b) (number? c)) (exp-optimizer `(+ ,(- b c) (- ,a ,d))))
            ((and (number? b) (number? d)) (exp-optimizer `(+ ,(- b d) (- ,a ,c))))
            (else `(- (+ ,a ,b) (+ ,c ,d)))))
    (define (-+- a b c d) ; (- (+ a b) (- c d))
      (cond ((eq? a c) (exp-optimizer `(+ ,b ,d)))
            ((eq? a d) (exp-optimizer `(+ (* 2 ,a) (- ,b ,c))))
            ((eq? b c) (exp-optimizer `(+ ,a ,d)))
            ((eq? b d) (exp-optimizer `(+ (* 2 ,b) (- ,a ,c))))
            ((and (number? a) (number? c)) (exp-optimizer `(+ ,(- a c) (+ ,b ,d))))
            ((and (number? a) (number? d)) (exp-optimizer `(+ ,(+ a d) (- ,b ,c))))
            ((and (number? b) (number? c)) (exp-optimizer `(+ ,(- b c) (+ ,a ,d))))
            ((and (number? b) (number? d)) (exp-optimizer `(+ ,(+ b d) (- ,a ,c))))
            (else `(- (+ ,a ,b) (- ,c ,d)))))
    (define (--+ a b c d) ; (- (- a b) (+ c d))
      (cond ((eq? a c) (exp-optimizer `(- 0 (+ ,b ,d))))
            ((eq? a d) (exp-optimizer `(- 0 (+ ,b ,c))))
            ((eq? b c) (exp-optimizer `(- (- ,a ,d) (* 2 ,b))))
            ((eq? b d) (exp-optimizer `(- (- ,a ,c) (* 2 ,b))))
            ((and (number? a) (number? c)) (exp-optimizer `(- ,(- a c) (+ ,b ,d))))
            ((and (number? a) (number? d)) (exp-optimizer `(- ,(- a d) (+ ,b ,c))))
            ((and (number? b) (number? c)) (exp-optimizer `(- (- ,a ,d) ,(+ b c))))
            ((and (number? b) (number? d)) (exp-optimizer `(- (- ,a ,c) ,(+ b d) )))
            (else `(- (- ,a ,b) (+ ,c ,d)))))
    (define (--- a b c d) ; (- (- a b) (- c d))
      (cond ((eq? a c) (exp-optimizer `(- ,d ,b)))
            ((eq? a d) (exp-optimizer `(- (* 2 ,a) (+ ,b ,c))))
            ((eq? b c) (exp-optimizer `(- (+ ,a ,d) (* 2 ,b))))
            ((eq? b d) (exp-optimizer `(- ,a ,c)))
            ((and (number? a) (number? c)) (exp-optimizer `(- ,(- a c) (- ,b ,d))))
            ((and (number? a) (number? d)) (exp-optimizer `(- ,(+ a d) (+ ,b ,c))))
            ((and (number? b) (number? c)) (exp-optimizer `(- (+ ,a ,d) ,(+ b c))))
            ((and (number? b) (number? d)) (exp-optimizer `(- (- ,a ,c) ,(- b d) )))
            (else `(- (- ,a ,b) (- ,c ,d)))))
    (define (-** a b c d) ; (- (* a b) (* c d))
      (cond ((and (number? a) (number? c) (symbol? b) (symbol? d) (eq? b d)) (exp-optimizer `(* ,(- a c) ,b)))
            ((and (number? a) (number? d) (symbol? b) (symbol? c) (eq? b c)) (exp-optimizer `(* ,(- a d) ,b)))
            ((and (number? b) (number? c) (symbol? a) (symbol? d) (eq? a d)) (exp-optimizer `(* ,(- b c) ,a)))
            ((and (number? b) (number? d) (symbol? a) (symbol? c) (eq? a c)) (exp-optimizer `(* ,(- b d) ,a)))
            ((eq? a c) (exp-optimizer `(* ,a (- ,b ,d))))
            ((eq? a d) (exp-optimizer `(* ,a (- ,b ,c))))
            ((eq? b c) (exp-optimizer `(* ,b (- ,a ,d))))
            ((eq? b d) (exp-optimizer `(* ,b (- ,a ,c))))
            (else `(- (* ,a ,b) (* ,c ,d)))))
    (define (*** a b c d) ; (* (* a b) (* c d))
      (cond ((and (number? a) (number? c)) (exp-optimizer `(* ,(* a c) (* ,b ,d))))
            ((and (number? a) (number? d)) (exp-optimizer `(* ,(* a d) (* ,b ,c))))
            ((and (number? b) (number? c)) (exp-optimizer `(* ,(* b c) (* ,a ,d))))
            ((and (number? b) (number? d)) (exp-optimizer `(* ,(* b d) (* ,a ,c))))
            (else `(* (* ,a ,b) (* ,c ,d)))))
    (define the-combine-both-patterns
      (list
       (cons '+
             (list
              (cons '+ (list (cons '+ +++) (cons '- ++-)))
              (cons '- (list (cons '+ +-+) (cons '- +--)))
              (cons '* (list (cons '* +**)))))
       (cons '-
             (list
              (cons '+ (list (cons '+ -++) (cons '- -+-)))
              (cons '- (list (cons '+ --+) (cons '- ---)))
              (cons '* (list (cons '* -**)))))
       (cons '*
             (list
              (cons '* (list (cons '* ***)))))))
    (define (combine-both op fst snd) ;; (+ (* 2 x) (* x 3)) => (* 5 x)
      (let ((a (cadr fst))
            (b (caddr fst))
            (op1 (car fst))
            (c (cadr snd))
            (d (caddr snd))
            (op2 (car snd)))
        (let ((p0 (assq op the-combine-both-patterns)))
          (if p0
              (let ((p1 (assq op1 (cdr p0))))
                (if p1
                    (let ((p2 (assq op2 (cdr p1))))
                      (if p2
                          ((cdr p2) a b c d)
                          `(,op ,fst ,snd)))
                    `(,op ,fst ,snd)))
              `(,op ,fst ,snd)))))
    (let ((a (cadr exp))
          (b (caddr exp))
          (op (car exp)))
      (cond
       ((and (pair? a) (pair? b)) (combine-both op a b))
       ((pair? a) (combine-single-b op a b))
       ((pair? b) (combine-single-a op a b))
       (else exp))))
  (define (reduce exp op sym)
    (let ((a (exp-optimizer (cadr exp)))
          (b (exp-optimizer (caddr exp))))
      (cond ((and (number? a) (number? b))
             (op a b))
            ((number? a)
             (if (= a 0)
                 (cond
                  ((eq? sym '+) b)
                  ((eq? sym '-) `(- 0 ,b))
                  ((eq? sym '*) 0)
                  ((eq? sym '/) 0))
                 (if (and (= a 1) (eq? sym '*))
                     b
                     (combine `(,sym ,a ,b)))))
            ((number? b)
             (if (= b 0)
                 (if (eq? sym '*)
                     0
                     a)
                 (if (and (= b 1) (or (eq? sym '/) (eq? sym '*)))
                     a
                     (combine `(,sym ,a ,b)))))
            ((eq? a b)
             (cond
              ((eq? sym '+) `(* 2 ,a))
              ((eq? sym '-) 0)
              (else (combine `(,sym ,a ,b)))))
            (else (combine `(,sym ,a ,b))))))
  (cond
   ((number? exp) exp)
   ((tagged-list? exp '+)
    (reduce exp + '+))
   ((tagged-list? exp '-)
    (reduce exp - '-))
   ((tagged-list? exp '*)
    (reduce exp * '*))
   (else exp)))

(define (layout-eval exp priority) ; (+ x y) => x + y
  (let ((exp (exp-optimizer exp)))
    (cond
     ((number? exp)
      (if (< exp 0)
          (string-append "(" (number->string exp) ")")
          (number->string exp)))
     ((tagged-list? exp '+)
      (if (> priority 0)
          (string-append "(" (layout-eval (cadr exp) 0) " + " (layout-eval (caddr exp) 0) ")")
          (string-append (layout-eval (cadr exp) 0) " + " (layout-eval (caddr exp) 0))))
     ((tagged-list? exp '-)
      (if (> priority 1)
          (string-append "(" (layout-eval (cadr exp) 1) " - " (layout-eval (caddr exp) 1) ")")
          (string-append (layout-eval (cadr exp) 1) " - " (layout-eval (caddr exp) 1))))
     ((tagged-list? exp '*)
      (string-append (layout-eval (cadr exp) 2) " * " (layout-eval (caddr exp) 2)))
     ((tagged-list? exp '/)
      (string-append (layout-eval (cadr exp) 2) " / " (layout-eval (caddr exp) 2)))
     (else (symbol->string exp)))))

(define (generate-view-frame var x y width height)
  (display (string-append (symbol->string var) ".frame = (CGRect) {" (layout-eval x 0) ", " (layout-eval y 0) ", " (layout-eval width 0) ", " (layout-eval height 0) "};"))
  (newline))

(define (frame-width f)
  (caddr f))

(define (frame-height f)
  (cadddr f))

(define (layout-^^ layout-fun root view x y width height gen?)
  (let ((up (up-view view))
        (low (low-view view))
        (margin (view-margin view)))
    (let* ((occupy1 (layout-fun root up x y width 0 gen?))
           (occupy2 (layout-fun root low x `(+ ,y (+ ,margin ,(frame-height occupy1))) width (if (and (number? height) (= 0 height)) 0 `(- ,height (+ ,margin ,(frame-height occupy1)))) gen?)))
      (list x y width `(+ (+ ,(frame-height occupy1) ,(frame-height occupy2)) ,margin)))))

(define (generate-view-will-layout-subviews env)
  (define (layout-loop tree)
    (define (layout root view x y width height gen?)
      (define (frame-width f)
        (caddr f))
      (define (frame-height f)
        (cadddr f))
      (cond
       ((eq? '^^ (view-type view))
        (layout-^^ layout root view x y width height gen?))
       ((eq? 'vv (view-type view))
        (let ((up (up-view view))
              (low (low-view view))
              (margin (view-margin view)))
          (let* ((occupy0 (layout root low x y width 0 #f))
                 (occupy1 (layout root up x y width (if (and (number? height) (= 0 height)) 0 `(- ,height (+ ,margin ,(frame-height occupy0)))) gen?))
                 (occupy2 (layout root low x `(+ ,y (+ ,margin ,(frame-height occupy1))) width (if (and (number? height) (= 0 height)) 0 `(- ,height (+ ,margin ,(frame-height occupy1)))) gen?)))
            (list x y width `(+ (+ ,(frame-height occupy1) ,(frame-height occupy2)) ,margin)))))
       ((eq? '<< (view-type view))
        (let ((left (left-view view))
              (right (right-view view))
              (margin (view-margin view)))
          (let* ((occupy1 (layout root left x y 0 height gen?))
                 (occupy2 (layout root right `(+ ,x (+ ,margin ,(frame-width occupy1))) y (if (and (number? width) (= 0 width)) 0 `(- ,width (+ ,margin ,(frame-width occupy1)))) height gen?)))
            (list x y `(+ (+ ,(frame-width occupy1) ,(frame-width occupy2)) ,margin) height))))
       ((eq? '>> (view-type view))
        (let ((left (left-view view))
              (right (right-view view))
              (margin (view-margin view)))
          (let* ((occupy0 (layout root right x y 0 height #f))
                 (occupy1 (layout root left x y (if (and (number? width) (= 0 width)) 0 `(- ,width (+ ,margin ,(frame-width occupy0)))) height gen?))
                 (occupy2 (layout root right `(+ ,x (+ ,margin ,(frame-width occupy1))) y (if (and (number? width) (= 0 width)) 0 `(- ,width (+ ,margin ,(frame-width occupy1)))) height gen?)))
            (list x y `(+ (+ ,(frame-width occupy1) ,(frame-width occupy2)) ,margin) height))))
       ((eq? 'above (view-type view))
        (let ((up (up-view view))
              (low (low-view view))
              (ratio (view-ratio view)))
          (if (and (number? height) (= 0 height))
              (let ((occupy1 (layout root up x y width 0 #f))
                    (occupy2 (layout root low x y width 0 #f)))
                (cond
                 ((and (number? (frame-height occupy1)) (= 0 (frame-height occupy1)) (number? (frame-height occupy2)) (= 0 (frame-height occupy2)))
                  (list x y width height))
                 ((and (number? (frame-height occupy1)) (= 0 (frame-height occupy1)))
                  (layout root low x y width (frame-height occupy2) gen?))
                 ((and (number? (frame-height occupy2)) (= 0 (frame-height occupy2)))
                  (layout root up x y width (frame-height occupy1) gen?))
                 (else (let ((h `(+ ,(frame-height occupy1) ,(frame-height occupy2))))
                         (layout root up x y width (frame-height occupy1) gen?)
                         (layout root low x `(+ ,y ,(frame-height occupy1)) width (frame-height occupy2) gen?)
                         (list x y width h)))))
              (let* ((occupy1 (layout root up x y width `(* ,height ,ratio) gen?))
                     (occupy2 (layout root low x `(+ ,y ,(frame-height occupy1)) width `(* ,height (- 1 ,ratio)) gen?)))
                (list x y width height)))))
       ((eq? 'beside (view-type view))
        (let ((left (left-view view))
              (right (right-view view))
              (ratio (view-ratio view)))
          (if (and (number? width) (= 0 width))
              (let ((occupy1 (layout root left x y 0 height #f))
                    (occupy2 (layout root right x y 0 height #f)))
                (cond
                 ((and (number? (frame-width occupy1)) (= 0 (frame-width occupy1)) (number? (frame-width occupy2)) (= 0 (frame-width occupy2)))
                  (list x y width height))
                 ((and (number? (frame-width occupy1)) (= 0 (frame-width occupy1)))
                  (layout root right x y (frame-width occupy2) height gen?))
                 ((and (number? (frame-width occupy2)) (= 0 (frame-width occupy2)))
                  (layout root left x y (frame-width occupy1) height gen?))
                 (else (let ((w `(+ ,(frame-width occupy1) ,(frame-width occupy2))))
                         (layout root left x y (frame-width occupy1) height gen?)
                         (layout root right `(+ ,x ,(frame-width occupy1)) y (frame-width occupy2) height gen?)
                         (list x y w height)))))
              (let* ((frame1 (layout root left x y `(* ,width ,ratio) height gen?))
                     (frame2 (layout root right `(+ ,x ,(frame-width frame1)) y `(* ,width (- 1 ,ratio)) height gen?)))
                (list x y width height)))))
       (else
        (let ((type-definition (assq (view-type view) the-type-definitions)))
          (if type-definition
              (let* ((var (lookup-variable-by-value view root))
                     (w (if (and (number? width) (= 0 width)) (string->symbol (string-append (symbol->string var) ".bounds.size.width")) width))
                     (h (if (and (number? height) (= 0 height)) (string->symbol (string-append (symbol->string var) ".bounds.size.height")) height)))
                (if (or (and (number? width) (= 0 width)) (and (number? height) (= 0 height)))
                    (begin
                      (display (string-append "[" (symbol->string var) " sizeToFit];"))
                      (newline)
                      (if gen?
                          (generate-view-frame var x y w h)))
                    (if gen?
                        (generate-view-frame var x y w h)))
                (list
                 (string->symbol (string-append (symbol->string var) ".frame.origin.x"))
                 (string->symbol (string-append (symbol->string var) ".frame.origin.y"))
                 (string->symbol (string-append (symbol->string var) ".bounds.size.width"))
                 (string->symbol (string-append (symbol->string var) ".bounds.size.height"))))
              (list x y width height))))))
    (if (not (null? tree))
        (let ((root (caar tree))
              (rootstr (symbol->string (caar tree)))
              (children (cdar tree)))
          (layout root children 0 0 (string->symbol (string-append rootstr ".bounds.size.width")) (string->symbol (string-append rootstr ".bounds.size.height")) #t)
          (layout-loop (cdr tree)))))
  (layout-loop the-layout-tree))

(define (generate-declaration-by-type-definition type var)
  (display (string-append type " * " (symbol->string var) ";"))
  (newline))

(define (generate-cell-declaration env)
  (let loop ((vars the-variables))
    (if (not (null? vars))
        (let ((definition (assq (view-type (cadar vars)) the-type-definitions)))
          (if definition
              (generate-declaration-by-type-definition (type-definition-type-string definition) (caar vars)))
          (loop (cdr vars))))))

(define (generate-cell-for-row-at-index-path env)
  (define (layout-loop tree)
    (define (layout root view x y width height gen?)
      '())
    (if (not (null? tree))
        (let ((root (caar tree))
              (rootstr (symbol->string (caar tree)))
              (children (cadr tree)))
          (layout root children 0 0 (string->symbol (string-append rootstr ".bounds.size.width")) (string->symbol (string-append rootstr ".bounds.size.height")) #t))))
  (layout-loop the-layout-tree))
